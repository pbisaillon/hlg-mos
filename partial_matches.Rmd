---
title: "partial_matching"
author: "INS"
date: "25/01/2022"
output: html_document
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo=TRUE)
library(plotly)
library(dplyr)

# Source R script from GitHub
satgpa <-
  read.csv("./data/satgpa.csv") %>%
  select(-sat_sum) 
  # removed this from the data set because it's dependent on sat_m and sat_v

synth_bisaillon <-
  read.csv("./synthpop/synth_data.csv")
```

# Record-matching as a privacy measure

Trying to match original records in synthetic data is a simple measure of privacy but a practical one. If a synthetic dataset were to be published, people would likely check whether they can find themselves in there.

## Full matches

### Can someone find themselves in the data?

If a record is fully replicated in the synthetic data, it is effectively disclosed.

Thankfully finding matches is easy to do in R. An inner-join of the original and synthetic data will quickly return all rows that match 100%.

```{r}
# Number of 100% matched rows
full_matches = merge(satgpa, synth_bisaillon) %>% nrow()

full_matches
```

```{r, echo=FALSE}
total_records = nrow(satgpa)
full_matches = merge(satgpa, synth_bisaillon) %>% nrow()

matches_df <- data.frame(
  label = c("Fully matched", "Not fully-matched"),
  value = c(full_matches, total_records - full_matches))

fig <- plot_ly(matches_df, labels = ~label, values = ~value, type = 'pie',
        textposition = 'inside',
        textinfo = 'label+percent',
        insidetextfont = list(color = '#FFFFFF'),
        hoverinfo = 'text',
        marker = list(colors = colors,
                      line = list(color = '#FFFFFF', width = 1)),
                      #The 'pull' attribute can also be used to create space between the sectors
        showlegend = FALSE)
fig <- fig %>% layout(title = 'United States Personal Expenditures by Categories in 1960',
         xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))

fig
```

## Partial matches

### Could someone recognize parts of their data?

Even if a record is not fully replicated, pieces of it may still be recognizable. For example, someone's neighbor might be able to make guesses with part of their data. Or if only 3 variables of a record are recognizable, it may still be perceived as disclosed.

In R it is possible to run the `merge()` function iteratively on all combinations of columns. The `combn()` function will return all permutations of a vectors.

```{r}
# Return all possible samples of size 2 from (a, b, c)
combn(c("a", "b", "c"), 2, simplify = FALSE)
```

Partial matches are more likely than full matches. The SAT dataset has a variable for sex, so it is nearly guaranteed that at least one column can be matched. As we try to match more and more columns, we get less matches.

```{r, echo=FALSE}
# Setup
num_cols <- length(satgpa)
columns_names <- names(satgpa)

base_df <- satgpa
base_df$index <- seq_len(nrow(base_df))

syn_df <- synth_bisaillon
syn_df$syn_index <- seq_len(nrow(syn_df))

levels_at_match <- data.frame(
  index=integer(),
  syn_index=integer(),
  match_level=integer()
)

for (x in rev(seq_len(num_cols))) {
  # Find all combinations of columns of x length
  combos <- combn(columns_names, x, simplify = FALSE)
  # For each combination, find all inner joins
  matches <- lapply(combos,
                      function(combo) {
                        m <- merge(base_df, syn_df, by = combo)
                        if (nrow(m) == 0) return(NULL)
                        m <- m[, c("index", "syn_index")]
                        m$match_level <- x
                        m
                      }
  )
  # Combine the successful inner joins
  matches <- unique(do.call(rbind, matches))
  # Append them to the tracking dataset
  levels_at_match <- rbind(levels_at_match, matches)
  # Remove the indexes that were matched, to make future inner joins faster
  base_df <- base_df[!base_df$index %in% matches$index, ]
}

# Prepare data for graphing
uniques <- unique(levels_at_match[, c("index", "match_level")])
cummulative_counts <- list()
for (x in rev(seq_len(num_cols))) {
  cummulative_counts[x] <- nrow(unique(uniques[uniques$match_level >= x, ]))
}

cummulative_counts <- data.frame(match_level = seq_len(num_cols),
                                 n = unlist(cummulative_counts))
# Rebase as percentages
cummulative_counts$n <- 100 * cummulative_counts$n / nrow(satgpa)
cummulative_counts$perc <- paste0(cummulative_counts$n, "%")

fig <- plot_ly(
  x = cummulative_counts$match_level,
  y = cummulative_counts$n,
  text = cummulative_counts$perc,
        hoverinfo = 'text',
  type = "bar",
        marker = list(line = list(color = 'rgb(8,48,107)',
                                  width = 1.5))) %>%
  layout(title = "Partial matches of original data (SAT)",
         xaxis = list(title = "Columns to match"),
         yaxis = list(title = "Percentage of rows matched"),
         bargap = 0)

fig
```